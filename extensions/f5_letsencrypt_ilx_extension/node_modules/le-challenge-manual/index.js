'use strict';

var Challenge = module.exports;

Challenge.create = function (defaults) {
  return  {
    getOptions: function () {
      return defaults;
    }
  , set: Challenge.set
  , get: Challenge.get
  , remove: Challenge.remove
  };
};

// Show the user the token and key and wait for them to be ready to continue
Challenge.set = function (args, domain, token, secret, cb) {
  console.info("");
  console.info("Challenge for '" + domain + "'");
  console.info("");
  console.info("We now present (for you copy-and-paste pleasure) your ACME Challenge");
  console.info("public Token and secret Key, in that order, respectively:");
  console.info(token);
  console.info(secret);
  console.info("");
  console.info(JSON.stringify({
    domain: domain
  , token: token
  , key: secret
  }, null, '  ').replace(/^/gm, '\t'));
  console.info("");
  console.info("hit enter to continue...");
  process.stdin.resume();
  process.stdin.on('data', function () {
    process.stdin.pause();
    cb(null);
  });
};

// nothing to do here, that's why it's manual
Challenge.get = function (args, domain, token, cb) {
  cb(null);
};

// might as well tell the user that whatever they were setting up has been checked
Challenge.remove = function (args, domain, token, cb) {
  console.info("Challenge for '" + domain + "' complete.");
  console.info("");
  cb(null);
};

Challenge.loopback = function (defaults, domain, challenge, done) {
  var hostname = domain + (defaults.loopbackPort ? ':' + defaults.loopbackPort : '');
  var urlstr = 'http://' + hostname + '/.well-known/acme-challenge/' + key;

  require('http').get(urlstr, function (res) {
    if (200 !== res.statusCode) {
      done(new Error("local loopback failed with statusCode " + res.statusCode));
      return;
    }
    var chunks = [];
    res.on('data', function (chunk) {
      chunks.push(chunk);
    });
    res.on('end', function () {
      var str = Buffer.concat(chunks).toString('utf8').trim();
      done(null, str);
    });
  }).setTimeout(defaults.loopbackTimeout, function () {
    done(new Error("loopback timeout, could not reach server"));
  }).on('error', function (err) {
    done(err);
  });
};

Challenge.test = function (args, domain, challenge, keyAuthorization, done) {
  var me = this;
  var key = keyAuthorization || challenge;

  me.set(args, domain, challenge, key, function (err) {
    if (err) { done(err); return; }

    myDefaults.loopbackPort = args.loopbackPort;
    myDefaults.webrootPath = args.webrootPath;
    me.loopback(args, domain, challenge, function (err, _key) {
      if (err) { done(err); return; }

      if (key !== _key) {
        err = new Error("keyAuthorization [original] '" + key + "'"
          + " did not match [result] '" + _key + "'");
        return;
      }

      me.remove(myDefaults, domain, challenge, function (_err) {
        if (_err) { done(_err); return; }

        done(err);
      });
    });
  });
};
